using System;
using System.IO;
using System.Globalization;
using System.Text;
using System.Collections.Generic;
using System.Linq;

namespace Amgcl.Matrix;

public class SparseMatrix
{
    private readonly int _rows;
    private readonly int _cols;
    private readonly Dictionary<(int, int), double> _values;

    public int Rows => _rows;
    public int Cols => _cols;

    public SparseMatrix(int rows, int cols)
    {
        this._rows = rows;
        this._cols = cols;
        _values = new Dictionary<(int, int), double>();
    }

    public double this[int row, int col]
    {
        get
        {
            if (row < 0 || row >= _rows || col < 0 || col >= _cols)
                throw new ArgumentOutOfRangeException("Row or column index out of range");
            return _values.TryGetValue((row, col), out double value) ? value : 0;
        }
        set
        {
            if (row < 0 || row >= _rows || col < 0 || col >= _cols)
                throw new ArgumentOutOfRangeException("Row or column index out of range");
            
            if (value == 0)
                _values.Remove((row, col));
            else
                _values[(row, col)] = value;
        }
    }

    public static SparseMatrix LoadFromMatrixMarketCoordinate(string filePath)
    {
        using var reader = new StreamReader(filePath);
        string? line;

        while ((line = reader.ReadLine()) != null && line.StartsWith("%")) { }
        if (line == null) throw new FormatException("Invalid Matrix Market file format");

        var sizes = line.Split(' ', StringSplitOptions.RemoveEmptyEntries);
        if (sizes.Length < 3) throw new FormatException("Invalid size specification");
        
        int rows = int.Parse(sizes[0]);
        int cols = int.Parse(sizes[1]);

        var matrix = new SparseMatrix(rows, cols);

        while ((line = reader.ReadLine()) != null)
        {
            var parts = line.Split(' ', StringSplitOptions.RemoveEmptyEntries);
            if (parts.Length < 3) continue;

            int row = int.Parse(parts[0]) - 1; // 1-based -> 0-based
            int col = int.Parse(parts[1]) - 1;
            double value = double.Parse(parts[2], CultureInfo.InvariantCulture);
            matrix[row, col] = value;
        }

        return matrix;
    }

     public static SparseMatrix LoadFromMatrixMarketArray(string filePath)
    {
        using var reader = new StreamReader(filePath);
        string? line;

        while ((line = reader.ReadLine()) != null && line.StartsWith("%")) { }
        if (line == null) throw new FormatException("Invalid Matrix Market file format");

        var sizes = line.Split(' ', StringSplitOptions.RemoveEmptyEntries);
        if (sizes.Length < 2) throw new FormatException("Invalid size specification");
        
        int rows = int.Parse(sizes[0]);
        int cols = int.Parse(sizes[1]);

        var matrix = new SparseMatrix(rows, cols);
        int row = 0, col = 0;

        while ((line = reader.ReadLine()) != null)
        {
            var parts = line.Split(' ', StringSplitOptions.RemoveEmptyEntries);
            foreach (var part in parts)
            {
                double value = double.Parse(part, CultureInfo.InvariantCulture);
                if (value != 0)
                    matrix[row, col] = value;

                row++;
                if (row >= rows)
                {
                    row = 0;
                    col++;
                    if (col >= cols) break;
                }
            }
        }

        return matrix;
    }

    public void SaveToMatrixMarketCoordinate(string filePath)
    {
        using var writer = new StreamWriter(filePath);
        
        writer.WriteLine("%%MatrixMarket matrix coordinate real general");
        writer.WriteLine($"% Generated by SparseMatrix class on {DateTime.Now}");
        writer.WriteLine($"{_rows} {_cols} {_values.Count}");

        foreach (var kvp in _values)
        {
            int row = kvp.Key.Item1 + 1; // 0-based -> 1-based
            int col = kvp.Key.Item2 + 1;
            double value = kvp.Value;
            writer.WriteLine($"{row} {col} {value.ToString(CultureInfo.InvariantCulture)}");
        }
    }

    public void SaveToMatrixMarketArray(string filePath)
    {
        using var writer = new StreamWriter(filePath);
        
        writer.WriteLine("%%MatrixMarket matrix array real general");
        writer.WriteLine($"% Generated by SparseMatrix class on {DateTime.Now}");
        writer.WriteLine($"{_rows} {_cols}");

        for (int j = 0; j < _cols; j++)
        {
            for (int i = 0; i < _rows; i++)
            {
                double value = this[i, j];
                writer.WriteLine(value.ToString(CultureInfo.InvariantCulture));
            }
        }
    }

    public SparseMatrix Add(SparseMatrix other)
    {
        if (_rows != other._rows || _cols != other._cols)
            throw new ArgumentException("Matrix dimensions must match");

        SparseMatrix result = new SparseMatrix(_rows, _cols);
        foreach (var kvp in _values)
            result[kvp.Key.Item1, kvp.Key.Item2] = kvp.Value;

        foreach (var kvp in other._values)
        {
            int row = kvp.Key.Item1;
            int col = kvp.Key.Item2;
            result[row, col] = result[row, col] + kvp.Value;
        }
        return result;
    }

    public SparseMatrix Multiply(SparseMatrix other)
    {
        if (_cols != other._rows)
            throw new ArgumentException("Matrix dimensions incompatible for multiplication");

        SparseMatrix result = new SparseMatrix(_rows, other._cols);
        foreach (var kvp1 in _values)
        {
            int row = kvp1.Key.Item1;
            int col1 = kvp1.Key.Item2;
            double val1 = kvp1.Value;

            foreach (var kvp2 in other._values)
            {
                if (kvp2.Key.Item1 == col1)
                {
                    int col = kvp2.Key.Item2;
                    double val2 = kvp2.Value;
                    result[row, col] = result[row, col] + val1 * val2;
                }
            }
        }
        return result;
    }

    public (double[] values, int[] colIndices, int[] rowPointers) ToCSR()
    {
        int nnz = _values.Count;
        double[] csrValues = new double[nnz];
        int[] colIndices = new int[nnz];
        int[] rowPointers = new int[_rows + 1];

        var sortedEntries = _values.OrderBy(kvp => kvp.Key.Item1)
                                   .ThenBy(kvp => kvp.Key.Item2)
                                   .ToList();

        int index = 0;
        for (int row = 0; row < _rows; row++)
        {
            rowPointers[row] = index;
            while (index < nnz && sortedEntries[index].Key.Item1 == row)
            {
                csrValues[index] = sortedEntries[index].Value;
                colIndices[index] = sortedEntries[index].Key.Item2;
                index++;
            }
        }
        rowPointers[_rows] = nnz;

        return (csrValues, colIndices, rowPointers);
    }

    // for testing

    public string Print()
    {
        var sb = new StringBuilder();
        for (int i = 0; i < _rows; i++)
        {
            for (int j = 0; j < _cols; j++)
                sb.Append($"{this[i, j],8:F2}");
            sb.AppendLine();
        }
        return sb.ToString();
    }

    public string PrintCSR()
    {
        var (csrValues, colIndices, rowPointers) = ToCSR();

        var sb = new StringBuilder();
        sb.AppendLine("CSR Format:");
        sb.Append("Values: ");
        sb.AppendLine(string.Join(" ", csrValues));
        sb.Append("Column Indices: ");
        sb.AppendLine(string.Join(" ", colIndices));
        sb.Append("Row Pointers: ");
        sb.AppendLine(string.Join(" ", rowPointers));
        return sb.ToString();
    }
}
